---
title: 'React的useState特点'
date: '2022-9-30'
excerpt: React的useState特点有哪些?
isFeatured: false
classify: 'React'
image:
codeDemo:
---

# React的useState特点

> 在函数体中修改了state 会触发组件的重新渲染 这时候呢 我们如果直接在函数体中修改state 可能会报错 to many ... 因为循环了, 重新渲染 修改state ...
>
> 怎么解决呢?

## State

```js
 *          setCount() ---> dispatchSetDate()
     *                            ---> 会先判断 组件当前处于什么状态
     *                            渲染阶段    不会检查state值是否相同
     *                            非渲染阶段  会检查state的值 是否相同
     *                              --  如果值不相同,  则对组件重新渲染
     *                              --  如果值相同     React在一些情况下 会继续执行当前组件的渲染
     *                                  但是这个渲染 不会触发其字组件的渲染, 这次渲染不会产生实际效果
     *                                  这种情况通常发生在值 第一次相同时
     
      count : 0
     *      第一次点击按钮 count --> 1
     *              'App 组件重新渲染了'  执行了
     *      第二次点击按钮 count ---> 1
     *          组件重新渲染了 执行了
     *      第三次点击按钮
     *           App组件重新渲染了  没执行
```



## Effect

> 逻辑如果直接卸载函数体中, 会影响到组件的渲染, 这时候会产生副作用的代码, 是一定不能直接卸载函数体中.
>
> 例如, 如果直接将修改state的逻辑写到了组件中,就会导致组件不断的重新渲染, 直至调用次数过多导致内存溢出报错为止



> * useEffect()  是一个钩子函数  需要一个函数作为参数

 - 这个作为参数的函数 将会在组件渲染完毕后执行

*      在开发中, 可以将那些会产生副作用的代码 编写到useEffect的回调函数中

```jsx
*    第二个参数 是一个数组  在数组中可以知道Effect的依赖项
*    指定后, 只有当以来发生变化时, Effect才会被触发
*    通常会将Effect中使用的所有变量 都设置会依赖性
*      这样一来 可以确保 这些值发生变化时, 会触发effect的执行
*    像setState是由钩子函数useState()生成的,
*        useState() 会确保组件的每次渲染 都会获取到相同的setState对象
*         所以像setState()可以不设置到以来中
*
*    如果依赖性 设置了一个空数组  则意味着 Effect只会在组件初始化时 触发一次
*    在Effect的回调函数中 可以指定一个函数作为返回值
*    这个函数可以称为清理函数, 它会在下次Effect执行前调用
*    我们可以在这个函数中 做一些工作 来清楚上次effect执行所带来的影响
```