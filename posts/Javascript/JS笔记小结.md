---
title: 'js笔记小结'
date: '2022-10-16'
excerpt: javaScript是世界上最流行的脚本语言,无论我们是在手机,平板,电脑还是在其他设备上,我们在访问浏览器时就会使用javascript.
isFeatured: false
classify: 'Javascript'
image:
codeDemo:
---

# javascript

> javaScript是世界上最流行的脚本语言,无论我们是在手机,平板,电脑还是在其他设备上,我们在访问浏览器时就会使用javascript.

## ECMAScript

### JS的应用

- 实现网页中的交互效果
- 小游戏
- 数据交互
- 用于服务器的开发(Node.js)
- ......

### JS的组成部分

| 组成       | 介绍                                                         |
| ---------- | ------------------------------------------------------------ |
| ECMAScript | 定义了JS的基本语法                                           |
| BOM        | Browser Object Model 浏览器对象模型,提供了与浏览器进行交互的API |
| DOM        | Document Object Model 文档对象模型,提供了对于HTML文档的操作的API |

### ECMAScript版本

| ES1    | ES2    | ES3    | ES4  | ES5    | ES5.1  | ES2015(ES6) | ES2016 | ES2017 | ES2018 | ES2019 | ...... |
| ------ | ------ | ------ | ---- | ------ | ------ | ----------- | ------ | ------ | ------ | ------ | ------ |
| 1997年 | 1998年 | 1999年 | 夭折 | 2009年 | 2011年 | 2015年      | 2016年 | 2017年 | 2018年 | 2019年 | .....  |

### JS的语法特点

> javasscript是基于对象和事件驱动的松散型解释性语言,它是单线程异步机制的一种语言

- 面向对象
- 由事件驱动
- 松散型(弱类型)
- 解释性(写一行解析一行)
- 单线程异步机制

### 如何向网页中添加JS脚本(JS文件的引入方式)

- 创建JS文件

  > 修改文件后缀名创建 : 1.txt  改为1.js
  >
  > 通过编辑器创建JS文件

- 引入外部JS文件

  ```html
  <script src="JS文件路径"></script>
  ```

- 嵌入式JS代码

  ```html
  <html>
      <head>
          <meta charset="utf-8">
          <title>document</title>
      </head>
      <body>
          <div>
              html内容
          </div>
          <script>
              // JS代码
          </script>
      </body>
  </html>
  ```

- 写在事件之后

  ```html
  <div onclick="alert('这是事件之后')">
      点我吧
  </div>
  ```

- 用于页面的重定向的地方

  ```html
  <a href="javascript:;">百度</a>
  ```

### JS中的调试工具

> 调试工具可以让程序与我们对话,能够去调解程序中的一些问题,快速的定位到错误地点

| 调试工具            | 描述                               |
| ------------------- | ---------------------------------- |
| document.write(str) | 将一段文本写入到HTML页面中         |
| .console.log(str)   | 将一段提示信息输出到控制台         |
| alert(str)          | 弹出一个具体确定按钮的警示信息     |
| confirm(str)        | 弹出一个具有确定取消按钮的警示信息 |
| prompt(str)         | 弹出一个具有确定取消按钮的对话框   |

### 名词解释

- 标识符

  > 标识类型
  >
  > 标识值

- 声明

  > 声明是指约定变量的声明周期和逻辑的作用域

  - 纯碎陈述值得过程,称为变量或类型的声明过程
  - 纯粹陈述逻辑的过程,称为语句(包含流程控制的子句)
  - 陈述值与逻辑关系的过程,称为表达式(但凡具有结果的语句,都称为表达式)

- 错误类型

  - 语法错误

    > 在执行js代码时,js解析器会先解析js基本语法,如果在解析过程中发现语法错误,程序就会中断.

  - 逻辑错误

    > 指的是JS的语法没有错误,但是程序运行产生了不正确的结果,这种错误比语法错误要难解决

- 语句结尾的分号

  > 每个分号都表示一条语句的结束

### 变量

> 所谓的变量,指的就是存储数据的容器,

#### 命名规范

- 严格区分大小写
- 命名必须以字母,$. _(下划线)开头,其余部分可以是数字,字母 ,下划线,$
- 不可以使用JS中的关键字和保留字
  - 关键字:指的是在Js中正在使用的具有特殊含义的单词(if.  else   for ...)
  - 保留字:指的是JS现在不用,但是未来可能会用的具有特殊含义的单词
- JS自己命名的习惯
  - 驼峰命名法:getElementByClassName
  - 首字母大写: Object
- 命名要有意义

#### 变量的声明

> 在JS中通过关键字var,let声明变量. 使用const声明常量

- 使用var声明变量

  ```js
  var 变量名;
  ```

- 使用let声明变量

  ```js
  let 变量名;
  ```

- 使用const [ ES6新增语法] 声明常量

  ```js
  const PI = 3.14;
  ```

  

- let声明和var声明的区别

  - var

    > 使用var声明的变量,在声明变量之前可以访问这个变量,这种现象叫变量提升

    ```js
    console.log(num)   // undefined
    var num = 10;
    ```

  - let

    > 使用let声明变量,不能再声明变量之前进行访问,不存在变量提升

    ```js
    consloe.log(num)	// 报错
    let num = 10 ;
    ```

#### 变量的赋值

- 先声明变量,再进行赋值

  ```js
  var num ;
  num = 1 ;
  
  let num1 ; 
  num1 = 1;
  ```

- 声明变量的同时进行赋值

  ```js
  var num = 1 ;
  ```

- 一次性声明多个变量然后再分别进行赋值,多个变量之间通过逗号','进行分隔

  ```js
  var num,num1,num2
  num= 0 ,num1 = 1,num2 = 3;
  ```

- 一次性声明多个变量的同时进行赋值,变量之间使用逗号分隔

  ```js
  var num = 1,num2 = 2,num3 = 3;
  ```

  **变量声明后,未赋值,变量的默认值为undefined**

### 常量

> 顾名思义:常量是指固定不变的量

**注意**

- 常量必须是在声明的同时进行赋值
- 常量一经创建,不可进行更新

**基本语法**

```js
const 常量名 = 常量值;
const PIc = 3.1415926;
```

### 数据类型

> JS中的数据类型根据数据在内存中的存储位置不同分为两大类,一类是初始数据类型(基本数据类型),一类是引用数据类型(复合数据类型)

#### 初始数据类型(基本数据类型)

> 初始数据类型(基本数据类型)保存在内存栈区中,是一些不可更改的数据.

> JS中的初始数据类型有六种:
>
> 1. 数值型(number)
> 2. 字符串型(string)
> 3. 布尔型(boolean)
> 4. undefined
> 5. null
> 6. Symbol(独一无二的)

- 数值型

  > 在JS中,数值型包括整型(整数)和浮点型号(小数),支持10进制,16进制,8进制,支持科学计数法

  | 进制     | 描述                                             |
  | -------- | ------------------------------------------------ |
  | 十进制   | 以一串数字组成,没有前缀0                         |
  | 八进制   | 以0(0O,0o)开头,数值只包含0-7                     |
  | 十六进制 | 以0x或者0X开头的数值,值包含0-9 .或者a~f 或者 A~F |
  | 二进制   | 二进制整数以0b或0B开头,只包含数字0,1             |

  - 科学技术法

    > 针对于一些较大的数值,我们需要进行科学技数法的表示
    >
    > 2e10:  2  *  10^10
    >
    > 2表示前面的数值
    >
    > 10表示10的10次方

  - JS中的最大值,最小值

    > 最大值: Number.MAX_VALUE
    >
    > 最小值:Number.MIN_VALUE

  - 无穷

    > 正无穷:Inifinity
    >
    > 负无穷:-Infinity

- 布尔型(boolean)

  > 用于表示一个值或者一个表达式的真假性

  - true:真

  - false:假

    > 在JS中, 数字0   ,空字符串("").  false,   null   undefined,   NaN ,  六种数据为假, 其余所有的数据都为真

- 字符串型(string)

  > 用单双引号来进行标记,凡是用单引号或者双引号包裹起来的都叫字符串

  - 单双引号在功能上没有区别,都用于标记字符串
  - 单引号不能嵌套单引号,双引号不能嵌套双引号
  - 同时单双引号不能交叉使用
  - 单双引号可以互相嵌套

  **引号包裹的字符串中间不能出现换行**

- undefined

  > undefined:未定义,表示变量声明但是未赋值的时候,变量默认值就是undefined

  - 变量声明未赋值,默认值为undefined
  - 使用var声明的变量,在声明之前访问变量,值为undefined
  - 函数未设置返回值的时候,默认返回值为undefined
  - 对象的属性未赋值的时候,默认值为undefined

- null

  > null:空.一般用于占位符 , null与Null,NULL完全不同,因为JS中严格区分大小写.

- Symbol

  > ES6中新增数据类型,表示独一无二的值

#### 引用数据类型(复合数据类型)

> 引用数据类型保存在内存的堆区,是一些可变的数据

> 引用数据类型包含两大类: object(对象)  ,function(函数)

##### 数据类型的判断

- 通过typeof判断某个变量保存数据的数据类型

  ```js
  typeof 数据/变量;
  ```

  **typeof判断数据类型的额可能结果如下表**

  | 数据类型     | 数据类型对应的typeof的结果 |
  | ------------ | -------------------------- |
  | undefined    | 'undefined'                |
  | null         | 'object'                   |
  | boolean      | 'boolean'                  |
  | string       | 'string'                   |
  | number       | 'number'                   |
  | Symbol       | 'symbol'                   |
  | 函数对象     | 'function'                 |
  | 其他所有对象 | 'object'                   |

## 运算符

> 在计算机中,我们会通过运算符对数据进行计算.在JS中,运算符分为以下七类
>
> - 算数运算符
> - 赋值运算符
> - 关系运算符
> - 逻辑运算符
> - 一元运算符
> - 三元运算符
> - 特殊运算符

### 算数运算符

> +(加), -(减)  ,* (乘) ,  / (除) ,% (取余) , **(求幂), ++ (自增) , --(自减)

**算数运算符,在对各种数据类型进行运算时的运算规则如下**

- 当数值型与除了字符串以外的其他数据类型进行算数运算时,会将非数值类型转换成数值类型然后进行算数运算,如果无法转换为数值类型,算数运算结果为NaN

  - 布尔值true会转换成数字1
  - 布尔值false,null会转换成数字0
  - undefined会转换成NaN    NaN表示not a number非数字

- NaN与除了字符串外的其余数据类型算数运算结果都为NaN

- 字符串与任意数据类型进行加法运算,结果都是拼接之后的字符串

- ++ , --

  - ++ ,-- 运算符在变量的前面

    > 会先将变量进行自增或自减,然后再参与别的运算

  - ++ ,-- 运算符在变量的后面

    > 会先参与其他运算,然后再对变量进行自增或自减

### 关系运算符(比较运算符)

> 运算符的运算结果是布尔值(boolean)

> >(大于),<(小于),>=(大于等于),<=(小于等于),==(相等),===(全等),!=(不相等),!==(不全等)

**关系运算符的运算规则**

- 数值型与数值型进行比较,正常比大小

- 关系运算符再进行比较时,会尝试将非数值类型的数据转换成数值类型进行比较,如果转换不了数值类型,结果是false

- 字符串与字符串进行比较时,会根据字符串中每一个字符对应的ASCII编码依次进行比较,直到能够比较出大小为止

- ==和===的区别

  - ==:是指运算符两侧的值相等即可

    - 特殊情况

      ```
      0 == undefined   // false
      0 == null     	 // false
      NaN == NaN 		 // false
      undefined == null // true
      ```

  - ===:运算符左右两侧的值和数据类型必须相等

### 赋值运算符

> = , +=, -= , *= , /= , %= , **= 

| 运算符 | 实例     | 等价于   |
| ------ | -------- | -------- |
| =      | a = 5    | a = 5    |
| +=     | a += 5   | a = a+5  |
| -=     | a -= 5   | a = a-5  |
| *=     | a *= 5   | a = a*5  |
| /=     | a /= 5   | a = a/5  |
| %=     | a %=5    | a = a%5  |
| **=    | a **=S 5 | a = a**5 |

### 逻辑运算符

> &&(与)  || (或) ,    !  (非)

1. && (与)

   - 运算符两侧只要有一侧为假,这个表达式的结果就为假
   - 运算符左侧为真,表达式最终的结果为右侧的值;如果运算符左侧为假.那么结果为左侧的值

2. || (或)

   - 运算符两侧只要有一侧为真,这个表达式结果就为真
   - 运算符左侧为假,表达式最终的结果为右侧的值,运算符左侧为真,结果为左侧的值

3. ! (非)

   > 取反,原来为真,取反后为假,原来为假,取反后为真.

   **短路原则,再与或运算中,如果运算符左侧的值能够决定这个表达式的真假性,那么最终结果就为左侧的值,不在去判断右侧值得真假性**

   - 与运算左侧为假,表达式结果就为左侧得值,不再看右侧值得真假性
   - 或运算左侧为真,表达式结果就为左侧得值,不再看右侧值得真假性

### 一元运算符

> 只有一个操作符得运算符,只能操作一个值得运算符就叫一元运算符

- new:实例化对象
- delete:删除
- typeof:判断数据类型
- -(负), +(正)
- instanceof:判断一个对象是否由某一个构造函数实例化而来

### 三元运算符

> 三元运算符是指.根据条件对变量进行动态赋值得一种条件运算符

```js
var 变量 = 表达式 ?  "表达式为真得结果" : "表达式假的结果"
```

### 特殊运算符

> ,  (逗号) , ()[小括号]

- ,  逗号用于分隔

```js
var num = 0,num1=1,num2=2
```

- ()小括号用于提升算数优先级

  ```js
  var res = (1+2) * 5;
  ```

### 运算符的优先级

<div style="color:red">需要补充</div>

**如果想要让我们的数据的操作根据我们的需求和要求进行执行,那么会用到JS中的流程控制**

## 流程控制

> 流程是指代码执行的顺序

> 流程控制;是根据我们的指令让代码按照一定的顺序执行,这就是流程控制

### 流程控制的分类

| 分类     | 描述                            |
| -------- | ------------------------------- |
| 顺序结构 | 代码正常的执行顺序              |
| 分支结构 | 根据条件是否满足,执行对应的代码 |
| 循环结构 | 在条件满足的情况下重复执行代码  |

#### 分支结构

**if分支**

- 单路分支

```js
if (条件) {
    // 条件满足时执行的代码
    }
```



- 双路分支

```js
if (条件) {
    // 条件满足时执行的代码
} else {
    // 条件不满足时执行的代码
}
```



- 多路分支

```js
if (条件一){
     // 条件1满足执行的代码
} else if (条件2){
    // 条件1不满足,但是条件2满足执行的代码
} else if (条件3) {
    // 条件1.2不满足,条件3满足执行的代码
}
....
else {
    // 条件都不满足时执行的代码
}
```



- 嵌套分支

```js
if (条件1){
    if(条件2){
       // 条件1 条件2满足执行的代码
       }else if(条件三){
           // 条件1满足,条件2不满足,条件3满足执行的代码
       }
}else{
    // 条件1不满足执行的条件
}
	
```



**switch分支**

```js
switch (被判断的值){
    case 值1:
        满足值1执行的代码;
        break
        case 值2:
        满足值2执行的代码;
        break
        case 值3:
        满足值3执行的代码;
        break
     default
        条件都不满足时执行的代码
}
```

### 循环结构

> 在条件满足的情况下,重复执行循环体;

#### for循环

```js
for (初始值;终止值;步进值){
    // 循环体.条件满足执行的代码
}
```

- 初始值:定义循环开始的位置
- 终止值:定义循环结束的位置
- 步进值:从开始到结束每一步前进多少,能够决定最终的循环次数(循环体的执行次数)
- 循环体:需要重复执行的代码

<div style="color:Red;font-weight:600; border:1px solid">for循环执行的顺序</div>

- 从初始值开始---->判断是否满足终止值条件---->满足条件---->执行循环体---->循环体执行结束执行步进值----->判断是否满足终止值条件---->满足就继续执行循环体

  ​		---->不满足就结束循环

  初始值开始---->判断是否满足终止值条件---->不满足条件---->终止循环体

#### while循环

```js
while(条件){
    // 循环体
}
```



#### do-while循环

```js
do {
    // 循环体
}while(条件)
```

**while和do-while的区别**

- while先判断条件,在判断循环体
- do-while先执行一次循环体,在判断条件
- 无论循环条件是否满足do-while都会执行一次循环体

**for与while循环的选择**

- 优先选择for循环
- 无法写出完整的初始值,终止值,步进值时使用while循环
- for循环必须知道循环次数,while循环只需要知道循环条件

**while的应用场景**

> 当不知道确切的循环次数的时候,需要使用while循环
>
> 当循环结束的条件是由循环体产生的时候使用while循环

### **循环控制语句**

- continue

  > 跳出本次循环,如果下一次循环条件还满足继续执行循环体

- break

  > 终止整个循环,无论后续循环条件是否满足,都不会执行循环体

### 函数

#### 函数的概念

> 函数:封装有一段具有特定功能的代码段

#### 函数的优点

- 增加代码的可复用性:一次编写,多次使用
- 增加代码的可阅读性,可维护性,让代码更加的整洁和具有逻辑性
- 可以通过向同一个函数传递不同的参数,实现不同的函数功能

### 函数的声明

- **使用function关键字**

  ```js
  function 函数名(参数1,参数2,参数3...){
      // 内部代码,也称为函数体
  }
  ```

  

- 使用字面量方式创建函数(通过变量赋值的方式)

  ```js
  var 变量 = function (参数1,参数2,参数3...){
      // 内部代码,也称为函数体
  }
  ```

**使用字面量方式创建的函数没有名称,只是将函数赋值给了变量,也被称为匿名函数**

- 实例化Function构造函数

```js
var 变量 =  new Function(参数1,参数2,参数3....函数体)
```

### 函数的调用

- 使用function关键字声明的函数调用

  ```js
  函数名();
  ```

- 使用字面量方式创建的函数调用

  ```js
  变量名 ();
  ```

- 函数自调用

  **函数自调用只会调用一次,所以一般会给只需要调用一次的代码进行函数自调用**

  ```js
  (function(){}) ();
  
  !function() {} ();
  
  ( function () {}() );
  ```

  ### 注意事项

- 如果两个函数的函数名相同,后声明的函数会将前面的覆盖

  ```js
  function aa(){
      console.log("我是前面的AA")
  }
  function aa(){
      console.log("我是后面的AA")
  }
  aa();   //我是后面的AA
  ```

- 使用function关键字声明的函数可以在声明之前访问,但是使用字面量方式创建的函数不能在创建之前进行调用

  ```js
  aa();  // 我是aa函数
  function aa(){
      console.log("我是aa函数")
  }
  ```

  ```js
  fun();  //报错
  var fn = function (){
      console.log("我是字面量方式创建的函数")
  }
  fun();   // 是字面量方式创建的函数
  ```

- 在不同的script代码块中访问顺序

  **在一个网页中可能会使用很多的script代码块,后面的script代码块可以访问前面声明的函数或变量,但是前面的script代码块不能访问后面的**

  ```html
  <script>
      function aa(){
          console.log("我是前面代码块的AA")
      }
      bb();   // 报错  not defined
  </script>
  <script>
      aa();   // 我是前面代码块的aa
      function bb(){
          console.log("我是后面代码块的AA")
      }
  </script>
  ```



#### ES6新增语法

- 箭头函数

  ```js
  // 有参数
  (参数1,参数2,参数3...) => {
      函数体
  }
  
  // 没有参数
  () => {}
  _ => {}
  
  // 如果函数体只有一条语句
  () => 语句;
  ```

- 箭头函数没有局部this的绑定

#### 函数的参数

> 可以动态修改函数内部变量的类型和值,使函数实现不同的功能

```js
function fn(a,b,c){
    console.log(a,b,c)
}
fun(1,2,3)  // 1 2 3
```

- 参数的分类

  - 形参

    > 形参指的是在创建函数时小括号内的参数称为形参,形式上的一种参数,只有当我们使用它时才有实际的意义

    ```js
    function aa(形参1,形参2,形参3){
        
    }
    ```

    

  - 实参

    > 实参:指的是在调用函数时小括号内的参数称为实参,实际存在的一种参数,能够供函数使用

    ```js
    function aa(形参1,形参2,形参3){
        
    }
    aa(实参1,实参2,实参3...)
    ```

- 参数的数据类型

  **无论是形参还是实参,他们可以支持任意数据类型,包括初始数据类型和引用数据类型**

  **当函数的参数是一个函数时,这个函数被称为回调函数,接收这个函数的形参相当于使用字面量方式创建函数,可以通过 形参名()进行调用**

- 参数的个数

  **默认形况下,形参与实参个数一一对应**

  - 实参数量 < 形参数量

    > 多余的形参默认为undefined

    ```js
    function a(a,b,c){
        console.log(a,b,c);	// 1 undefined undefined
    }
    aa(1);
    ```

    

  - 实参数量 > 形参数量

    - 在函数内部,通过arguments对象接收所有传递进来的实参,可以通过这种方式获取到多余的实参

      ```js
      function aa(a,b,c){
          console.log(arguments);	//[1,2,3,4,5,6,7]
          console.log(a,b,c);		// 1 2 3
      }
      aa(1,2,3,4,5,6,7)
      ```

      

    - 通过rest剩余参数接收所有多余参数,会将这些参数放置在一个数组中

      ```js
      function aa(a,b,c,...rest){
          console.log(arguments);	//[4,5,6,7]
          console.log(a,b,c);		// 1 2 3
      }
      aa(1,2,3,4,5,6,7)
      ```

- 参数的默认值

  **如果调用函数时没有传递相应的实参,形参的默认值为undefined,undefined对于程序运行没有意义所以我们会给参数设置默认值**

  - ES6设置参数默认值

    > 在创建函数时,对小括号内的形参之间赋值

    ```js
    function aa(a = 0,b = 0){
        console.log(a+b)
    }
    aa(); 		// 0
    aa(1,2);	// 3
    ```

  - ES5设置默认值

    > 在创建函数后,在函数体中根据逻辑或运算的短路原则给形参设置默认值

    ```js
    function aa(a,b){
        a = a || 0;
        b = b || 0;
        console.log(a+b);
    }
    aa();   // 0
    aa(1,2) // 3
    ```

- 参数尾逗号

  > 放置在参数末尾的逗号,在添加新的参数时不需要再写逗号,末尾的参数再调整位置是不需要添加逗号

  ```js
  funciton fn(a,b,c,){
      
  }
  fn(1,2,3,)
  ```

- 函数重载

  > 根据函数的参数个数不同或者数据类型不同,实现不同的函数功能,这个就是函数的重载

  ```js
      function fn(a) {
          if ( typeof a === 'number') {
              alert("这是一个数值型,它的值是:" + a)
          } else if (typeof a === 'string') {
              alert("这是一个字符串型,它的值是:" + a)
          } else if (typeof a === 'boolean') {
              alert("这是一个布尔型,它的值是:" + a)
          }else {
              alert("我不认识你!")
          }
      }
      fn()
  ```

  

#### 函数的返回值

> 再函数的函数体中,运算的结果可以输出到控制台进行查看,但是无法将这个结果参与其他的运算,如果想要让如果能够运用于其他地方,需要使用返回值

> 返回值:通过return语句将函数的运算结果返回给函数

```js
function aa(a,b){
    return a + b;
}
var res = aa(1,2,);
console.log(res);   // 3
```

#### return的作用

- 将函数运算结果返回给函数

- 中断后续函数的执行,再return语句后面的代码不会执行

  ```js
  function aa(a, b, c){
      var num = a * b * c;
      console.log("这是返回值设置之前");
      return num;
      console.log("这是返回值设置之后");
  }
  aa(2,5,9);   // 这是返回值设置之前
  /*在return num;语句之后的console语句没有被执行*/
  ```

#### 返回值设置的注意事项

- 返回值可以是任意数据类型

- 每个函数都有返回值,如果没有return语句,js会默认设置函数的返回值为undefined

- 一个函数有且只有一个返回值

  **但是一个函数可以有多个return语句,但是只有一个return会生效**

- 如果有多个返回值的时候,不可以使用逗号进行分隔

  ```js
  function aa(a,b,){
      var sum = a + b;
      var num = a * b;
      return sum ,num;
  }
  // return语句再设置返回值时会进行赋值,赋值的顺序是从左往右,用逗号隔开后右边的值会将前面的值覆盖,所以最终结果就是最右边的值
  ```

  **如果确实有多个返回值,可以将多个返回值放置在一个数组或对象中,将这个数组或对象作为返回值**

  #### 回调函数

  > 将一个函数(a)的指针作为另一个函数(b)的参数,并且再函数(b)中调用函数(a),函数(a)就被称为回调函数

  ```js
  function callback(){
      console.log("回调函数callback");
  }
  function fn(a){
      a();
  }
  fn(callback);  //回调函数callback
  // 当我们调用fn函数时,将callback函数作为参数传给了fn,形参a接收到函数callback并且进行了调用,这个call函数就是回调函数
  // 注意: 回调函数的形式
  //  1. 函数名
  //	2. 将整个函数作为参数进行传递
  //	3. 使用箭头函数简化回调函数
  ```

  

## 数组

> 数组:是用于存储大量的或一系列相关数据的容器

#### 数组的创建

- 隐式创建

  > 隐式的调用 new Array()进行创建

  ```js
  var arr = [];
  ```

- 实例化构造函数

  ```JS
  var arr = new Array();
  ```

#### 数组的赋值

**数组通过数组的下标进行赋值**

<div style="color:red;">下标是指数组中数据的唯一标记,方便对数据进行操作,下标从0开始,一直到数组的长度减1结束(length-1)</div>

```js
var arr = [];
arr[0] = 10;
arr[1] = 11;
arr[2] = 12;
arr[3] = 13;
console.log(arr)    // [10,11,12,13]
```

**在创建数组的同时进行赋值**

```js
var arr = [10,11,12,13];
var arr = new Array(10,11,12,13) // 实例化构造
```

#### 数组的访问

**通过数组的下标访问数组中的元素/数据**

**数组中元素的下标从0开始最大下标比数组的长度小1**(数组.length-1)

**数组的长度: 数组.length**

```js
var arr = [1,2,3,4,5,6];
console.log(arr[0]);  //1
console.log(arr[1]);  //2
console.log(arr.length);  // 5
```

#### **数组的遍历**

> 遍历:是指通过循环将数组中的数组依次提取出来进行操作,这个过程称为遍历

> 在for循环中,将初始值设为0.终止值设为数组的长度,步进制设为1,可以得到于数组下标相同的数字,将这些数字作为数组的下标就可以依次访问到数组的数据

- for循环遍历

  ```js
  var arr = [11,22,33,44,55,66];
  for (var i = 0 ; i < arr.length ; i++){
      console.log(arr[i])  // 11  22  33 44 55 66
  }
  ```

  

- for...in循环遍历

  ```js
  var arr = [3,4,5]
  for(var i in arr){
      console.log(i);  //  0   1   2   i表示的是数组的下标
      console.log(arr[i]) //  3  4   5
  }
  ```

- ES6新增的语法 for...of遍历

  ```js
  var arr = [3,4,5]
  for(var i of arr){
      console.log(i);  //  3   4   5   i表示的是数组的下标
  }
  ```

#### 二维数组

> 二维数组是指一个数组的数组元素还是一个数组

```js
var arr = [
    [1,2,3],
    [4,5,6],
    [7,8,9]
]
// 二维数组的遍历
// 外层循环遍历出来一维数组
for(var i = 0 ; i < arr.length ; i++){
    console.log(arr[i]) // [1,2,3]	[4,5,6]	[7,8,9]
    // 内层循环遍历出来二维的数组数据
    for (var j = 0 ; j < arr[i].length ; j++){
        console.log(arr[i][j]); // 1 2 3 4 5 6 7 8 9
    }
}

```

#### 数组拓展

##### ES6新增语法

- 数组的解构赋值

  > 将数组中的元素依次提取出来对变量进行赋值,这个过程称为解构赋值

  ```js
  var [a,b,c] = [1,2,3];
  console.log(a,b,c);   // 1  2  3
  ```

  - 解构赋值的应用

    - 不需要第三变量进行数据的交换

      ```js
      var a = 10, b = 20;
      [a,b] = [b,a];
      console.log(a,b)  // 20 10
      ```

      

    - 应用于函数的参数传递和接收

      ```js
      function fn([a,b,c]){
          console.log(a,b,c);  // 2  3  4
      }
      fn([2,3,4])
      ```

      

    - 应用于函数的返回值的设置和接收

      ```js
      function fn([a,b,c]){
          var num = a * b * c;
          var str = a +"-" + b+ "-" + c;
          return [sum,num,str];
      }
      var [r,p,q] = fn([3,4,5]);
      console.log(r,p,q); 	// 12 60 "3-4-5"
      ```

- 扩展运算符

  > ...就是扩展运算符,扩展运算符可以将数组中的数据依次提取出来(将数组扩展开来)

  ```js
  var arr = [5,6,7,8,9];
  console.log(...arr)  // 5 6 7 8 9
  ```

  - 扩展运算符的应用

    - 用于接收剩余参数

    ```js
    function fn(a,b,c,....arr){
        console.log(arr);  // [4,5,6,7]
    }
    fn(1,2,3,4,5,6,7)
    ```

    - 用于数组的拷贝

      ```js
      var arr = ['a','b','c'];
      var arr1 = [...arr];
      console.log(arr1);	// ['a','b','c']
      ```

    - 用于两个数组的拼接

      ```js
      var arr = ['a','b','c'];
      var arr1 = [1,2,3,4];
      var newArr = [...arr,...arr1];
      console.log(newArr);     // ['a','b','c',1,2,3,4]
      ```

      **使用扩展运算符进行的拷贝和数组的拼接是浅拷贝,要谨慎使用,浅拷贝:如果原来的数组数据发生了变化,拷贝后的新数组也会发生变化**

### 对象

> 在JS中一切皆对象,为了编程更加的好理解,我们将JS中的部分工具作为对象.
>
> 对象:指得是属性得无序集合

#### 对象得组成

- **属性**

  > 用于描述对象得状态

- **方法**

  > 用于描述对象得行为
  >
  > 方法:当对象得属性保存得属性值为函数时,这个属性被称为方法15

#### 对象的创建

- 隐式创建

  > 隐式调用new Object创建对象

  ```js
  var obj = {};
  ```

  

- 实例化Object构造函数

  ```js
  var obj1 = new Object();
  ```

- 实例化自定义构造函数

  ```js
  function Animal(){
      
  }
  var cat = new Animal();
  ```

  

- 实例化class类型[ES6新增]

  ```js
  class People{
      
  }
  var zhangsan = new People();
  ```

  #### 对象的赋值

  - 对象.属性名 = 属性值

    ```js
    var obj = {};
    obj.name = "女神!!"
    ```

  - 对象[属性名] = 属性值;

    ```js
    var obj = {};
    obj["name"] = "男神!!"
    ```

  - 创建对象的同时进行赋值

    ```js
    var obj = {
        name:"张三",
        age:19,
        sex:"男"
    }
    ```

#### 对象的访问

- 对象属性名

  ```js
  var obj = {
      name: "女神"
  }
  console.log(obj.name);  // 女神
  ```

- 对象[属性名]

  ```js
  var obj = {
      name:"女神"
  }
  console.log(obj["name"])  // 女神
  ```

#### 对象的更新

- 对象.属性名 = 新的属性值

  ```js
  var obj = {
      name:"女神"
  }
  obj.name = "李沁"
  console.log(obj.name);  //李沁
  ```

- 对象[属性名] = 新的属性值

  ```js
  var obj = {
      name:"女神"
  }
  obj["name"] = "李沁"
  console.log(obj.name);  //李沁
  ```

#### 对象的删除

- 删除对象的单个属性

  ```js
  delete 对象.属性名;
  delete 对象[属性名];
  ```

- 销毁对象

  ```js
  对象 = null;
  ```

#### 对象的判断

> 在编程过程中有时会需要判断对象的具体类型,使用instanceof关键字
>
> 这个关键字用于判断一个对象是否由某一个构造函数实例化而来

```js
对象 instanceof 构造函数
// 如果是返回true 如果不是返回false
```

#### 对象的遍历

> 通过for  in循环进行遍历

```js
var obj = {
    name:"jod";
    age: 18;
    weight:80
}
for(var i in obj){
    console.log(i) // name age weight
    console.log(obj[i]); // jod 18 80
}
```

**当对象的属性名保存在一个变量中时,我们不可以使用(对象.属性名)来访问,必须使用中括号(对象[变量名])来访问属性值**

#### ES6新增对象特性

- class创建对象

  ```JS
  class 类名 {
      
  }
  ```

- 对象属性方法的简写

  ```js
  // 当对象属性的属性值保存在变量中,并且变量名与属性名相同,可以省略掉其中的一个
  var username = "张三";
  var obj = {
      // username: username 可以简写成下面的代码
      username
  }
  //  方法的简写,可以直接以 方法名(){} 进行方法的定义
  var obj1 = {
      say(){
          // 函数体
      }
  }
  ```

- 对象的rest参数

  (拓展)

- 对象的解构赋值

  > 将对象中的数据提取出来赋值给变量

  ```js
  var {a,b,c} = {
      a:1,
      b:2,
      c:3
  }
  console.log(a,b,c) //  1 2 3
  ```

  **对象的解构赋值,赋值时是根据对象的属性名与变量名一一对应,无论变量的顺序如何变化,只要名称没有变化,那么值就不会变**

  **数组的解构赋值,赋值时是根据变量的书写顺序一一对应,所以变量的顺序发生变化,值也会跟着发生变化**

  


# BOM

> BOM:Brower Object Model 浏览器对象模型,提供了一些操作浏览器的方法和接口,可以通过这些方法去控制浏览器窗口

> 在BOM中,核心对象就是window对象

### window对象

#### window对象的属性

| 属性            | 介绍                   |
| --------------- | ---------------------- |
| **innerWidth**  | **浏览器窗口的宽度**   |
| **innerHeight** | **浏览器窗口的高度**   |
| screen.width    | 屏幕的宽度(屏幕分辨率) |
| screen.height   | 屏幕的高度(屏幕分辨率) |
| top             | 返回最顶层的window对象 |

#### window对象的方法

| 方法                           | 介绍                                               |
| ------------------------------ | -------------------------------------------------- |
| alert                          | 弹出一个具有确认按钮和警示信息的警示框             |
| confirm                        | 弹出一个具有提示信息和确认取消按钮的警示框         |
| prompt                         | 弹出一个具有提示信息和确认取消按钮的对话框         |
| open                           | 通过脚本打开新窗口                                 |
| close                          | 关闭当前窗口                                       |
| **scrollBy(x,y)**              | **根据指定的偏移量将页面滚动到响应的位置**         |
| **scrollTo(x,y)**              | **将文档滚动到指定位置**                           |
| **setinterval(callback,time)** | **每隔一段时间(time)执行一次回调函数(callback)**   |
| **clearlnterval()**            | **清除setlnterval设置的时间函数**                  |
| **setTimeout(callback,time)**  | **过一段时间(time)以后执行一次回调函数(callback)** |
| **clearTimeout()**             | **清除setTimeout设置的时间函数**                   |

**注意,在ES5中,声明全局变量的过程其实相当于在window对象新增了一个属性**

**在ES6中,全局变量于window对象的属性脱离关系,声明的全局变量不会再window对象身上新增属性**

```js
// ES5
var num = 0;
console.log(num)  / / 再window对象上有属性num 属性值是0
```

```js
// ES6
let a = 100;
console.log(a); // 再window上没有属性a
```

### console对象

### location对象

> location对象是window对象的子对象,它存储了与网页URL相关的详细信息,并且将这些信息划分成详细的片段,我们可以根据location对象的属性来访问这些详细片段

**location对象的属性**

> 一个完整的网页URL地址包含的9大部分
>
> 协议://  用户名   密码     域名   :端口号     /网页的地址; 参数 ?查询字符串  #标记
>
> **一个网页必备的三个部分,协议+域名+网页地址 ,拥有这三部分就可以进行访问**

| 属性              | 介绍                                             |
| ----------------- | ------------------------------------------------ |
| location.href     | 返回包含完成URL路径的字符串,可以进行修改         |
| location.origin   | 返回包含完整协议域名端口号的字符串,只读,无法修改 |
| location.protocol | 返回网页的协议字符串,带有一个冒号,只读,无法修改  |
| location.host     | 返回包含完整域名端口号的字符串,只读,无法修改     |
| location.hostname | 返回网站域名,只读,无法修改                       |
| location.port     | 返回网站端口号,只读,无法修改                     |
| location.pathname | 返回网页的地址,只读,无法修改                     |
| location.search   | 返回网页的查询字符串,只读,无法修改               |
| location.hash     | 返回网页的标记,只读,无法修改                     |

```js
https://www.baidu.com:8080/demo/index.html?pass=123456&name=joney#
```

##### location对象的方法

| 方法                     | 介绍                                                         |
| ------------------------ | ------------------------------------------------------------ |
| location.assign(url)     | 加载给指定url地址的页面资源                                  |
| location.reload(boolean) | 重新加载当前网页的资源,参数如果传递true,不管服务器端的网页资源是否发生变化,都会重新从服务器加载一遍,如果传递false,会将本地保存的网页资源与服务器端网页资源进行比较,如果改变了就重新请求,如果没有改变,就使用本地的网页资源进行刷新 |
| location.replace(url)    | 用给定url地址的资源替换当前资源                              |
| location.toString()      | 返回当前网页的完整url路径,但是不能修改,与location.href返回的结果一致 |

### history对象

> history对象是window对象的子对象,保存有我们曾经在浏览器或框架中打开的网页,我们可以用过其中的属性或方法对这些记录进行访问和操作

#### 属性

- length:返回当前页面历史记录的条数

#### history对象的方法

| 方法                   | 参数            | 返回值    | 描述                                                 |
| ---------------------- | --------------- | --------- | ---------------------------------------------------- |
| history.back()         | 无              | undefined | 回退到历史记录中的前一条记录与history.go(-1)功能一致 |
| history.forward()      | 无              | undefined | 前进到历史记录中的下一条记录与history.go(1)功能一致  |
| history.go(num)        | number          | undefined | 根据number进入到当前历史记录中的指定记录             |
| history.pushState()    | state,title,url | undefined | 无刷新的向历史记录中添加一条历史记录                 |
| history.replaceState() | state,title,url | undefined | 无刷新的替换历史记录中的一条历史记录                 |

#### 前端路由

> 前端路由是现在SPA(单页面应用)必备的功能,当下前端框架中都有自己的路由实现,包括vue-router,react-router,无论是vue还是react框架中的路由,其本质就是在使用hash模式或者H5 history模式

**前端路由是指在不发送http请求的前提下,实现网页的刷新效果,可以在一个网页中实现多个功能**

> 前端路由的实现,无论是hash模式还是history模式思路都是相同的
>
> 1. 定义个对象来保存用户需要注册的路由
> 2. 通过hashchange或者popstate来监听网页hash值得变化或者历史记录得更新
> 3. 监听到变化后,将变化后得值传递给前面得对象obj去找到相应得属性值,来执行这个路由下相对应得代码

#### Navigator对象

> navigator对象保存了与浏览器相关得一些信息,比如当前浏览器支持得语言,当前浏览器对cookie得支持等,我们可以通过属性方法来查看这些相关信息

navigator对象得属性

| 属性                    | 描述                                                         |
| ----------------------- | ------------------------------------------------------------ |
| navigator.language      | 返回当前浏览器得语言类型,zn-CN ,  en                         |
| navigator.cookieEnabled | 当前浏览器是否支持cookie操作,返回值是布尔值true   false      |
| navigator.onLine        | 判断当前浏览器是否是联网状态,,返回值是布尔值true   false     |
| navigator.platform      | f返回当前浏览器得操作系统平台,win32,Linux i686 MacPPC Maclntel等 |
| navigator.userAgent     | y有客户机发送给服务器得请求头信息(用户代理)                  |



## DOM	

> DOM: Document Object Model(文档对象模型) ,用来呈现或于HTML,XML交互的API文档,DOM以节点树的形式展示文档,每一个节点都是文档的一部分内容

### DOM对象的属性

> 如何访问DOM对象,通过document来访问

| 属性            | 介绍                     |
| --------------- | ------------------------ |
| URL             | 返回网页的URL地址        |
| charset         | 文档的字符集             |
| title           | 文档的标题               |
| forms           | 查看文档中所有的form元素 |
| images          | 查看文档中所有的img元素  |
| body            | 获取body元素             |
| head            | 获取head元素             |
| documentElement | 获取HTML根元素           |
| cookie          | 当前网页cookie值得情况   |

### DOM的方法

| 方法                                     | 描述                                                     |
| ---------------------------------------- | -------------------------------------------------------- |
| document.write(str)                      | 动态的向页面中输入内容                                   |
| document.getElementsByTagName(标签名)    | 在js中通过元素的标签名获取DOM元素                        |
| document.getElementsByClassNmae(类名)    | 在JS中通过元素的类名获取DOM元素,结果是一个类数组集合     |
| document.getElementByi(id值)             | 在js中通过元素的id属性值获取DOM元素,结果是元素本身       |
| document.getElementsByNmae(name属性值)   | 在js中通过元素的name属性值获取DOM元素,结果是一个节点列表 |
| **document.querySelector(css选择器)**    | **在js中通过css选择器获取DOM节点,结果是元素本身**        |
| **document.querySelectorAll(css选择器)** | **在js中通过css选择器获取DOM节点,结果是节点列表**        |

tagname和classname: 因为页面中的标签会有多个,类名也可以用于多个元素,所以获取到的DOM元素会放置在一个HTML元素集合中,哪怕只有一个DOM元素也会放在集合中,这是一个类数组的集合,所以想要访问具体的元素需要根据下标访问,

name属性值获取到的DOM元素会被放在一个类数组的节点集合中,如果访问具体的DOM元素也需要使用下标

下面那两个重要的获取到的DOM元素会被放在一个类数组的节点集合中,访问具体同样需要下标

1. 对象.setAttribute("")

### 操作DOM元素的内容

| 属性        | 介绍                                                  |
| ----------- | ----------------------------------------------------- |
| innerHTML   | 获取或修改DOM元素的内容,可识别标签并且能保留文本格式  |
| innerText   | 获取或修改DOM元素的内容,只识别纯文本,不能保留文本格式 |
| textContent | 获取或修改DOM元素的内容,只识别纯文本,保留文本格式     |

### 操作DOM元素的行内样式

> 通过js设置的元素样式均为行内样式

```js
元素.style.属性名 = 样式值;
元素.style.cssText = 样式名和样式值组成的字符串;
```

```js
var box = document.querySelector(".box")
box.style.width = "200px";
box.style.height = "200px";
box.style.boxshadow = "0 0 10px 5px red"
box.style.cssText = "background-color:red;font-size:16px;"
```

**在JS中具有特殊含义,遇到需要连字符链接的css样式,需要采用驼峰命名法,从第二个单词开始首字母大写**

**如果想要获取通过css样式表设置的元素属性,需要使用window.getComputedStyle()进行获取**

### 元素的属性

#### 元素子代属性

对象.属性   可以通过console.dir(对象)查看对象所有的属性

#### 自定义属性

- 对象.setAttribute("属性名","属性值");
- 对象.getAttribute("属性名");   获取属性名所对应的属性值,方法的返回值是属性值
- 对象.removeAttribute("属性名");   移出指定属性
- 对象.hasAttribute("属性名");  判断是否具有某一个属性,返回值是布尔值,true代表具备属性, flase代表没有这个属性

### 事件基础

> js是由事件驱动的一门脚本语言.
>
> 事件:指的是能够被浏览器监听到的用户行为.比如鼠标点击,鼠标滑过,鼠标移动,键盘按下,滚轮滚动等等

#### 事件的三要素

- 事件源

  > 触发事件的目标,一般是DOM元素

- 事件

  > 用户的行为,比如鼠标点击,鼠标移入移出

- 事件处理程序

  > 当事件触发时,需要完成的代码或功能,一般是一个函数

#### 常见的事件

##### 鼠标事件

| 事件          | 描述                         |
| ------------- | ---------------------------- |
| onclick       | 鼠标单击事件                 |
| ondblclick    | 鼠标双击事件                 |
| onmousedown   | 鼠标按下事件                 |
| onmouseup     | 鼠标抬起事件                 |
| onmousemove   | 鼠标移动事件                 |
| onmouseover   | 鼠标移入事件                 |
| onmouseout    | 鼠标移出事件                 |
| onmouseenter  | 鼠标移入事件(不支持事件冒泡) |
| onmouseleave  | 鼠标移出事件(不支持事件冒泡) |
| oncontextmenu | 鼠标右键事件                 |

##### 键盘事件

##### 表单事件

##### 其他事件



## DOM节点

> DOM文档其实是一个节点树,是由节点组成的,我们可以根据节点间的关系来确定DOM元素基本操作,DOM文档指的是HTML文档,在HTML中出现的所有内容都可以称为节点,比如div标签,文本内容,属性,注释

#### DOM节点树

#### 节点分类

| 节点     |                             描述                             |
| -------- | :----------------------------------------------------------: |
| 元素节点 |                    HTML标签被称为元素节点                    |
| 文本节点 |    在HTML中出现的文本内容,包括空格换行等都被称为文本节点     |
| 属性节点 | HTML中标签上的属性成为属性节点,比如href,src,alt,name,value等 |
| 注释节点 |                  HTML中的注释被称为注释节点                  |
| 文档节点 |                     整个文档就是一个节点                     |

#### 节点详细信息

| 节点     | 节点类型(node Type) | 节点名称(nodeName) | 节点的值(nodeValue) |
| -------- | ------------------- | ------------------ | ------------------- |
| 元素节点 | 1                   | 大写的标签名"DIV"  | null                |
| 属性节点 | 2                   | 属性名             | 属性值              |
| 文本节点 | 3                   | #text              | 文本的内容          |
| 注释节点 | 8                   | \#comment          | 注释的文本内容      |
| 文档节点 | 9                   | \#document         | null                |

#### 节点间的关系

**节点的属性**

| 属性                 | 描述                         |
| -------------------- | ---------------------------- |
| node.parentNode      | 获取node节点的父节点         |
| node.childNodes      | 获取node节点的子节点         |
| node.firstChild      | 获取node的第一个子节点       |
| node.lastChild       | 获取node的最后一个子节点     |
| node.nextSibling     | 获取node节点的下一个兄弟节点 |
| node.previousSibling | 获取node节点的上一个兄弟节点 |

**使用节点与节点间的关系去确定一些节点,会出现一些无用的空文本节点,一些null等,这些对我们的程序没有任何意义,所以一般我们会使用元素节点与元素节点间的关系进行程序的编写**

##### 元素节点间关系的属性

| 属性                           | 描述                                |
| ------------------------------ | ----------------------------------- |
| element.parentElement          | 获取element元素的父元素节点         |
| element.children               | 获取element元素的子元素节点         |
| element.firstElementChild      | 获取element元素第一个子元素节点     |
| elenent.lastElementChild       | 获取element元素最后一个子元素节点   |
| element.childElementCount      | 获取element元素子元素的个数         |
| element.nextElementSibling     | 获取element元素的下一个兄弟元素节点 |
| element.previousElementSibling | 获取element元素的前一个兄弟元素节点 |

### 节点方法

| 方法                                   | 介绍                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| document.createElement(元素节点名称)   | 创建一个元素节点,返回值是创建好的元素节点                    |
| document.createTextNode()              | 创建一个文本节点                                             |
| parentNode.appendChild(子节点)         | 向parentNode节点的最后面插入一个子节点                       |
| parentNode.insertBefore(新节点,旧节点) | 向parentNode节点中的旧节点前面添加一个新节点                 |
| parentNode.removeChild(子节点)         | 移出一个parentNode节点的子节点                               |
| node.cloneNode(boolean)                | 克隆一个node节点,参数是boolean值,如果参数为true,会将node节点本身以及节点所有内容都克隆,如果是flase只克隆node节点本身,不会克隆内部的其他内容 |

### 事件高级

#### 事件监听

> 事件监听,能够给同一个事件源的同一个事件添加不同的事件处理程序,也就是一个事件可以执行多个操作.

- 添加事件监听

  ```js
  var box = document.querySelector(".box");
  box.addEventListener("click",callback,boolean);
  事件源.addEventListener("被监听的事件","事件处理程序",boolean);
  ```

  - 被监听的事件:click, mouseover ,mouseout , mousemove ...
  - 事件处理程序:是一个回调函数,可以是函数本身,也可以是一个函数的指针
  - boolean:true表示捕获型事件,false表示冒泡型事件,默认值为false

- 移除事件监听

  ```js
  var box = document.querySelector(".box");
  box.addEventListener("click",callback,boolean);
  box.removeEventListener("click",callback,boolean);
  事件源.removeEventListener("被移出的监听事件","事件处理程序",boolean);
  ```

  - **事件处理程序:必须是一个具名函数,这个地方不能直接放置函数本身,必须是函数名或者变量名**

- 事件监听的兼容性写法

  ```js
  function addEvent(ele,type,callback,bool){
      try{
          ele.addEventListener(type,callback,bool);
      }catch(e){
          try{
              ele.attachEvent("on"+type,callback);
          }catch(e){
              ele["on"+type] = callback;
          }
      }
  }
  ```

### 事件对象

> 当一个事件触发的时候,与这个事件相关的很多信息都会被保存在一个对象中,这个对象就是事件对象,比如点击事件点击的位置,鼠标移动事件移动过的位置等等

**默认情况下事件处理函数的第一个函数就是事件对象**

```js
对象.事件 = function(e){
    // e就是事件对象
}
```

**事件对象的属性和方法**

- 鼠标相关事件

| 属性    | 介绍                                                  |
| ------- | ----------------------------------------------------- |
| clientX | 事件触发时鼠标距离浏览器X轴的距离                     |
| clientY | 事件触发时鼠标距离浏览器顶部的距离                    |
| offsetX | 事件触发时鼠标距离事件源左边的距离                    |
| offsetY | 事件触发时鼠标距离事件源顶部的距离                    |
| pageX   | 事件触发时鼠标距离HTML文档左边的距离,包括能滚动的部分 |
| pageY   | 事件触发时鼠标距离HTML文档顶部的距离,包括能滚动的部分 |

- 与鼠标滚轮事件相关

| 属性       | 介绍       |
| ---------- | ---------- |
| wheelDelta | 滚轮滚动量 |

**向上: 120  240**

**向下: -120  -240**

- 与键盘事件相关

  | 属性     | 介绍                |
  | -------- | ------------------- |
  | key      | 当前所按键的名称    |
  | keyCode  | 当前按键的键盘码    |
  | ctrlKey  | 判断ctrl键是否按下  |
  | altKey   | 判断alt键是否按下   |
  | shiftKey | 判断shifKey是否按下 |

- 事件对象方法

  | 方法              | 介绍                 |
  | ----------------- | -------------------- |
  | preventDefault()  | 阻止浏览器默认行为   |
  | stopPropagation() | 阻止事件流的传播     |
  | currentTarget     | 当前被绑定事件的元素 |
  | target            | 指向事件源           |
  | type              | 当前所触发事件的名称 |


### 事件流

> 事件流:当一个事件触发时,会在事件源与DOM节点间按照一定的顺序进行传递,在这个过程中所经过节点都会接收到这个事件,这个叫做dom事件流
>
> 顺序  :冒泡型事件流
>
> ​	   捕获型事件流

- 冒泡型事件流

  > 事件传播时,从最下往上,从最明确的事件源到最不明确的事件源

- 捕获型事件流

  > 事件传播时,从下往上,从最不明确的事件源到最明确的事件源

#### 事件流的传播顺序

**任何一个事件在发生时都会经历三个阶段**

- 事件捕获阶段:捕捉到事件的发生,开始进行事件流的传递
- 事件触发阶段:已经传递到事件源,开始触发事件源的事件
- 事件冒泡阶段:事件源的事件出发完成,将这个事件向上传播

**先捕获,后自身,再冒泡**

**但是有一些特殊的事件会跳过冒泡阶段,比如focus,blur**

**再事件监控中第三个参数false是冒泡,true是捕获**

**阻止事件流传播:事件对象中的stopPropagation方法阻止事件流传播**



### 事件委派

> 事件委派:利用事件冒泡,将事件添加到元素的父元素身上,等待其中的子元素事件冒泡,根据事件对象中target属性来确定是哪一个子元素,然后再去执行相应的操作

- 应用场景

  - 当多个子元素要执行同一个事件同一个事件处理程序时,可以使用事件委派
  - 当页面中的元素通过js动态生成的,可以使用事件委派统一添加事件

- 如何使用

  ```js
  父元素.addEventListener(事件,function(){
      e = e || event;
      // 根据事件对象的target属性来判断当前是哪一子元素触发了事件
      var ele = e.target;
      // 针对这个子元素要执行的函数体
      ...
  },false)
  ```

  #### 自定义事件

  > 自定义事件,就是自己定义一些需要的事件,与JS的原生事件不同,原生事件我们直接使用即可

  **自定义事件的创建**

  - 使用event构造器创建

    ```js
    var my_event = new Event("事件名称");
    ```

  - 使用CustomEvent构造器(如果需要传递数据,使用这种方法)

    ```js
    var my_event = ne CustomEvent("事件名称",{
        detail : {
            
        }
    }
    )
    // 将需要传递的数据保存再detail中,可以通过事件对象的detail属性获取, event.detail
    ```

  **自定义事件的监听**

  > 加入将这个自定义事件的监听放在window对象上

  ```js
  window.addEventListener("自定义事件名称",function(e){
      e = e || event;
      console.log(e.detail); //保存了从自定义事件中传递过来的数据
  },false);
  ```

  **自定义事件的触发**

  > 原生事件触发的时候需要特定的事件源,自定义事件需要我们主动的去触发使用dispatchEvent触发,兼容低版本的IE浏览器使用fieeEvent触发

  ```js
  if(window.dispatchEvent){
      window.dispatchEvent(my_event);
  }else{
      window.fireEvent(my_event);
  }
  ```

  



### 元素的位置尺寸相关

#### 元素的偏移

| 属性         | 介绍                                           |
| ------------ | ---------------------------------------------- |
| offsetWidth  | 元素实际宽度                                   |
| offsetHeight | 元素的实际高度                                 |
| offsetLeft   | 元素距离第一个具有定位属性的祖先元素左边的距离 |
|              |                                                |

### 

### 预解析与作用域

> 运行环境:运行环境是指javaScript代码执行的运行的地方

- 宿主环境:JS运行的平台或者软件,一般是指浏览器
- 执行环境:定义了变量和函数有权访问的其他数据,定义了他们之间的关系
  - 全局环境
  - 函数环境
  - eval

**根据JS代码的执行环境不同,这些代码访问数据时的权力不同,这个现象就是作用域**

#### 作用域

> 作用域:一段代码起作用的范围就是作用域
>
> 如果代码在全局环境中都起作用那么就拥有全局作用域
>
> 如果一段代码只在函数环境中起作用那么就拥有局部作用域

#### 作用域链

> 当访问一个变量或者函数的时候,会从当前作用域中寻找这个变量或函数,如果没有,会去大一级的作用域中去寻找,以此类推,一直找到全局作用域,如果全局作用域也没有这个变量或函数,会报错 is not undefined

**使用var在全局环境下声明的变量才是真正的全局变量**

**划分作用域主要是为了垃圾回收,当函数执行结束以后,一些变量就可以被注销掉,节省内存空间**

#### 预解析

> javaScript解析器在JS代码执行时,会将变量,函数提升到当前作用域的最顶端,再按照顺序执行

##### 预解析的顺序

- 按照\<script></script>代码块进行解析
- 再代码块内部按照执行环境进行解析
  - 全局环境:当页面打开的时候就进行解析
  - 函数环境:当函数被调用时进行解析
- 再按照环境解析的过程中,遇到var和function关键字,会将它们提取解析到内存中,方便访问
- 如果还有script代码块,继续按照上面的顺序进行解析

**因为js是分块解析的,所以后面的script代码块能够访问前面的script代码块中的变量和函数,前面的无法访问后面的**



### 函数高级

#### 回调函数

> 将一个函数的指针作为另一个函数(fn1)的参数,并且,再fn1中调用fn,那么fn函数就被称为回调函数

#### 递归函数

> 在一个函数内部调用函数本身,这个函数就是递归函数
>
> **递归函数使用不当会陷入死循环,所以一定要有终止的条件**

- 递归函数的应用

  - 需要重复不断的执行某一段代码的场景

  - 应用于对象的深拷贝或者求阶乘

    ```JS
    function jiecheng(num){
        if(num == 1){
            return 1;
        }else {
            return num * jiecheng(num-1);
        }
    }
    var res = jiecheng(5);
    console.log(res); // 120
    ```

#### 闭包函数

> 在一个函数fn外部有权访问fn内部的变量,那么这个fn函数就是一个闭包函数

```js
function outer(){
    var num = 100;
    return function() {
        return num;
    }
}
var res = outer();
console.log(res);  // 100
//在outer函数中定义了变量num,但是在函数外部无法进行访问,于是利用作用域,在outer函数内部的函数能够访问num变量将num的值作为内部函数的返回值返回给outer函数的外部,这样外部就可以使用num变量的值,但是在外部修改的这个值,不会对函数内部num变量造成影响
```

#### 块级作用域

> 在ES5中不存在块级作用域,所以以下代码在循环结束后能够访问到i变量

```js
for(var i = 0 ; i < 10 ; i++){
    
}
console.log(i) //10
```

> 在ES5中在变量声明之前也能够访问这个变量,不会报错,但是这是一种不正常的不严谨的现象,所以在ES6最终出现了块级作用域,拥有块级作用域的变量,只会在这个作用域中起作用,离开后无法被访问到

```js
for (let i = 0; i < 10 ; i++){
    
}
console.log(i); // 报错
```

### 对象的特性详解

> 了解这部分内容能够帮助我们理解访问对象属性和方法时的规则,并且能够了解到对象的由来

- 封装:对象会尽可能的将内部的具体细节隐藏起来,只提供有限的接口供外界访问,可以使数据更加安全,也便于管理
- 继承:对象中的一些公共的属性和方法是继承过来的,
- 多态:同一个属性或方法在对应不同的对象时,具有不同的状态,这个被称为多态

#### 封装

- 工厂函数封装(不推荐使用)

  > 将创建一个对象的过程封装在一个函数中,并将创建好的对象作为函数的返回值

  ```js
  function createObj(name,age,sex,height,)
  ```

- 构造函数封装

  > 将创建对象时可能会使用的属性或方法都先存放在this对象中,当我们在实例化构造函数时,将this的指向指向我们的对象

  ```js
  function Animal(name,age,sex){
      this.name = name;
      this.age = age;
      this.sex = sex;
  }
  var donkey = new Animal("绿",5,"公")
  ```

  **构造函数创建对象时,会将很多公共的属性和方法,不断的在内存中创建,导致内存空间的浪费,所以提出了原型的解决方法**

  - 原型:原型分为构造函数的原型和对象的原型

    > 原型是用来存储公共的属性和方法的对象,一般我们使用构造函数结合原型来实现对象的创建

  - 原型的访问和设置

    - 构造函数的原型

      ```js
      构造函数.prototype = {}
      ```

    - 对象的原型

    ```JS
    对象.__proto__
    ```

- 原型链

  **原型链:访问一个对象的属性或方法时,会从对象自身开始寻找,如果没有就去对象的构造函数中寻找,如果还没有,就去构造函数的原型中寻找,如果还没有就去构造函数的原型的构造函数去寻找,一直找到Object和null.如果属性不存在就返回undefined如果方法不存在会报错,**

- new操作符的原理

  ```js
  // new 操作符的原理
  // 1. 创建一个空对象
  // var obj = {};
  // 2. 将构造函数的原型赋值给obj对象的原型
  // obj.__proto__ = Animal.prototype
  // 3. 
  ```

#### 继承

> 在JS中很多时候我们需要使用继承的方式,将一些对象中的属性和方法引入到另一个对象中,可以进行访问,这个就是继承的过程
>
> 继承:JS中的继承是指在一个对象的基础上创建一个新对象,并且新对象能够访问原对象的属性和方法

##### JS中实现对象继承的方法

- 原型继承

  > 将父类的实例赋值给子类的原型(将父构造函数的实例赋值给子构造函数的原型)

  ```js
  Son.prototype = new Father();
  ```

- call

  > 通过修改对象方法的this指向来实现继承

  ```js
  var father = new Father();
  var son = new Son();
  
  father.say.call(son,"参数1","参数2",....)//将父对象的say方法的this指向从父对象改为子对象实现继承,传递参数的方式是将所有参数放在括号内,通过逗号隔开
  ```

- apply

  ```js
  var father = new Father();
  var son = new Son();
  
  father.say.apply(son,"参数1","参数2",....)//将父对象的say方法的this指向从父对象改为子对象实现继承,传递参数的方法是将所有的参数放在一个数组中
  ```

- bind

  ```JS
  var father = new Father();
  var son = new Son();
  
  father.say.bind(son,"参数1","参数2",....)//将父对象的say方法的this指向从父对象改为子对象实现继承,传递参数的方式是将所有参数放在括号内,通过逗号隔开
  ```

  **call方法与apply方法唯一区别就是传参方式不同,call和apply继承的方法都是立即执行函数,bind方法用法与call相同,传参与call相同,但是bind不是立即执行函数,会先将继承来的函数进行保存,当有需要的时候再进行调用**

### Javascript原生对象

#### 数组对象

##### 数组对象的属性

- length:返回数组对象的长度(数组元素的个数)
- constructor:返回数组对象的构造函数
- /__proto__:数组对象的原型,保存了继承的方法

##### 数组对象的方法

- arr.**push**(参数1,参数2,参数3....)

  - 功能:arr.push()向数组的末尾添加一个或多个数组元素
  - 参数:被添加的数组元素
  - 返回值:添加之后的数组长度
  - **会修改原数组**

- arr.**unshift**(参数1,参数2,参数3....)

  - 功能:向数组的开头添加一个或多个数组元素
  - 参数:被添加的数组元素
  - 返回值:添加之后的数组长度
  - **会修改原数组**

- arr.**pop**()

  - 功能:删除数组末尾的一个元素
  - 参数:无
  - 返回值:被删除的数组元素
  - **会修改原数组**

- arr.**shift**()

  - 功能:删除数组开头的一个元素
  - 参数:无
  - 返回值:被删除的数组元素
  - **会修改原数组**

- arr.**splice**(起始下标,删除个数,添加元素1,添加元素2,....);

  - 功能:再数组的任意位置添加或删除元素
  - 参数:
    - 起始下标:删除或添加开始的位置
    - 删除元素:要删除的元素个数,如果不删除设置为0
    - 添加元素:要添加的元素
  - 返回值:被删除的元素组成的数组,如果没有删除的元素,就是一个空数组
  - **会修改原数组**

- arr.**slice(起始下标,[结束下标]);**

  - 功能:截取数组中的一部分,不包含结束下标对应的元素.
  - 参数
    - 起始下标:截取开始的位置
    - 结束下标:截取结束的位置,如果没有结束下标,会从起始下标开始,截取到数组末尾
      - **参数支持负数**0
  - 返回值:被截取的元素组成的数组
  - **不修改原数组**

- arr.**join**(连接符)

  - 功能:根据指定的连接符,将数组中的元素拼接成一个字符串
  - 参数:连接符
  - 返回值:拼接后的字符串
  - **不修改原数组**

- arr.**sort**([callback]);

  - 功能:对数组中的元素进行排序

  - 参数:

    - 无参数:会按照数组元素的ASCll编码值大小进行升序排列

    - 有参数:参数必须是一个回调函数.回调函数接收两个参数

      ```js
      arr.sort((a,b) =>{
          // return a - b;  // 升序排列
          // return b - a;  // 降序排列
      })
      ```

  - 返回值:排序后的数组

  - **会修改原数组**

- arr.**forEach(callback,thisValue);**

  - 功能:数组遍历
  - 参数:
    - callback,回调函数
    - thisValue: 指定函数的this指向
  - 返回值:undefined
  - 不修改原数组

- arr.**filter**(callback,thisValue);

  - 功能:根据回调函数的返回值筛选数组中满足条件的数据
  - 参数:
    - callback 回调函数
    - thisValue:指定函数的this指向
  - 返回值:被筛选出来的数组元素组成的数组
  - **不修改原数组**

- arr.**map(callback,thisValue);**

  - 功能:对根据回调函数对数组中的元素进行映射
  - 参数
    - callback 回调函数
    - thisValue
  - 返回值:映射之后的新数组
  - **不修改原数组**

- arr.**some(callback,thisValue);**

  - 功能:判断是否有满足callback回调函数条件的数组元素,如果有返回true,如果没有返回false
  - 参数
    - callback
    - thisValue
  - 返回值:布尔值
  - **不修改原数组**

- arr.**every(callback,thisValue)**

  - 功能:判断数组中的元素是否全部满足callback回调函数的条件,如果满足返回true,如果有一个不满足返回false
  - 参数
    - callback
    - thisValue
  - 返回值布尔值
  - **不修改原数组**

- arr**.reverse()**;

  > 对数组进行翻转

- arr.**includes()     [ES6新增]**

  - 功能:用于判断数组中是否存在一个元素
  - 参数:被判断的元素
  - 返回值:布尔值
  - **不修改原数组**

- arr.**indexOf(元素);**

  - 功能:正序查找元素再数组中出现的下标,如果没有这个元素,返回-1
  - 参数:被查找的元素
  - 返回值:元素再数组中对应的下标,如果不存在返回-1
  - **不修改原数组**

- arr.**lastindexOf(元素);**

  - 功能:倒叙查找元素再数组中出现的下标,如果没有这个元素,返回-1
  - 参数:被查找的元素
  - 返回值:元素再数组中对应的下标,如果不存在返回-1
  - **不修改原数组**

- **Array.of(参数1,参数2...);**

  - 功能:将参数转换成一个数组
  - 参数:需要转换为数组的元素
  - 返回值:转换成功后的数组

- **Array.from(类数组对象,callback);**

  - 功能:将一个类数组的对象转换成真正的对象
  - 参数:需要转换的对象,callback回调函数(对转换的数组进行操作)
  - 返回值:转换之后的数组
  - **不修改原来的对象**

- arr.**concat(参数1,参数2..);**

  - 功能:用于将两个或者多个数组进行拼接
  - 参数:需要进行拼接的数组或元素
  - 返回值:拼接之后的新数组
  - 不修改原数组

- arr.**reduce(callback,initValue);**

  - 功能:对数组元素进行累加
  - 参数:
    - 回调函数callback(total,currentValue,currentindex,arr)
    - initValue:传递给回调函数的初始值
  - 返回值:累加之后的结果
  - **不修改原数组**
  - arr.reduceRight()

#### 字符串对象

##### 字符串对象属性

- length:字符串的长度,字符串中字符的个数,包括空格
- \__proto__:字符串对象原型,保存有继承而来的方法

##### 字符串对象的方法

1. str.charAt(下标)

   - 功能:根据对应的下标返回对应的字符
   - 参数:下标
   - 返回值:下标对应的字符
   - **不修改原字符串**

2. str.charCodeAt(下标);

   - 功能:根据下标返回下标对应的字符ASCII编码
   - 参数:下标
   - 返回值:下标对应字符的ASCII编码
   - **不修改原字符串**

3. String.fromCharCode(ASCII编码);

   - 功能:根据指定的ASCII编码返回对应的字符
   - 参数:ASCII编码值
   - 返回值:编码对应的字符

4. str.indexOf(字符);

   - 功能:正序查找字符第一次出现的下标,如果没有返回-1
   - 参数:需要查询的字符
   - 返回值:字符对应的下标,如果不存在返回-1

5. str.lastIndexOf(字符)

   - 功能:倒序查找字符第一次出现的下标,如果没有返回-1
   - 参数:需要查询的字符
   - 返回值:字符对应的下标,如果不存在返回-1

6. str.replace(旧字符.新字符);

   - 功能:使用新字符替换匹配到的旧字符,支持正则
   - 参数;
     - 参数1:要替换的旧字符
     - 参数2:被替换的新字符
   - 返回值:替换后的新字符串
   - **不修改原字符串**

7. str.slice(起始下标,结束下标);

   - 功能:截取字符串的指定位置支持负数
   - 参数:
     - 参数1:起始下标,截取开始的位置
     - 参数2:结束下标,截取结束的位置,但是截取的字符不包含结束下标
   - 返回值:被截取的新字符串
   - **不修改原字符串**

8. str.substring(起始下标,结束下标);

   - 功能:截取字符串的指定位置 不支持负数
   - 参数:
     - 参数1:起始下标,截取开始的位置
     - 参数2:结束下标,截取结束的位置,但是截取的字符不包含结束下标
   - 返回值:被截取的新字符串
   - **不修改原字符串**

9. str.substr(起始下标,截取的长度);

   - 功能:从起始下标开始,截取指定长度的字符串
   - 参数:
     - 参数1:截取开始的位置
     - 参数2:截取字符串的长度
   - 返回值:被截取后的新字符串
   - **不修改原字符串**

10. str.split(分隔符);

    - 功能:根据指定的分隔符,进行分隔
    - 参数需要分隔的字符串
    - 返回值:分隔后的数组
    - **不修改原字符串**

11. str.toLowerCase();

    - 功能:将字符串中的大写字母转换为小写
    - 参数:无
    - **不修改原字符串**

12. str.toUpperCase();

    - 功能:将字符串中的大写字母转换为大写
    - 参数:无
    - **不修改原字符串**

13. str.trim();

    - 功能:将字符串左右空格去除
    - 参数;无
    - **不修改原字符串**

14. str.match()

    - 功能:在字符串内检索指定的值
    - 参数:可以是字符串也可以是正则表达式
    - 返回值;检测到的结果
    - **不修改原字符串**

15. str.concat(参数1,参数2..)

    - 功能:用来连接两个或多个字符串
    - 参数:多个字符串
    - 返回值:拼接后的长字符串
    - **不修改原字符串**

16. str.padStart()   str.padEnd()

    - 功能:给字符串前面或后面添加字符,使字符达到指定的长度

    - 参数:
      - 参数1:当前字符串需要添加到的目标长度
      - 参数2:填充字符串
    - 注意事项:
      - 目标长度小于字符串长度,返回字符串本身
      - 填充的字符串太长,只保留目标长度内的字符串
      - 不写第二个参数默认用空格填充
      - 填充的字符串会自动重复直到到达指定的长度
      - 原字符串长度大于等于目标长度,返回原字符串

    #### 日期对象(Date)

    > Date对象是用来处理JS中与时间相关的问题的,JS中日期对象保存的时间是1970-01-01 00:00:00开始到今天所经历的毫秒数

    #### 日期对象的创建

    ##### 日期对象的方法

    > ##### 获取日期信息的方法

    > **设置日期信息的方法**

    **获取时间戳的方法**

    ```js
    Date.parse(new Date()); //获取当前的时间戳,但是会将毫秒改为0 不准确 不推荐使用
    (new Date()).valueOf();   // 使用对象方法valueOf
    new Date().getTime();
    Number(new Date());
    Date.now();
    ```


#### Object对象

##### **JS对象的分类**

- 内置对象:JS预备好的对象,不需要实例化可以之间访问

  - 内置顶层对象:Math

- 本地对象

  - String
  - Object
  - Array
  - Number
  - Boolean

- 宿主对象

  - DOM, BOM

    > 宿主:JS的执行环境

  **Object对象属性**

  - constructor
  - prototype

  **Object对象的方法**

  1. Object.assign(obj1,obj2...);

     > 用于对象的拼接,将obj2拼接到obj1对象里面,返回值是拼接后的obj1对象,会修改obj1,但是对其他对象没有影响

     ```js
     // 可以用于对象拷贝
     var obj = {
         name:"莫言",
         work:"作家",
         text:""
     };
     var res = Object.assign({},obj)
     ```

  2. Object.is(参数1,参数2);

     > 用于判断两个值是否相同,与 ===类似但不完全相同

     ```js
     Object.is(0,-0);  //false
     Object.is(NaN,NaN); //true
     ```

  3. Obj.prototype.isPrototypeOf(obj1);

     > 判断一个对象是否存在于另一个对象的原型链中(obj对象是否存在于obj1的原型链中)

     ```js
     function A(){
         
     }
     var a = new A();
     var res = A.prototype.isPrototypeOf(a);
     console.log(res);  //true
     ```

  4. Object.defineProperty(obj,property,description)

     > 在一个对象上定义一个属性

  5. Object.defineProperties(obj,props);

     > 在一个对象上定义多个属性,这些属性相关配置如下

     | 配置         | 描述                                                         |
     | ------------ | ------------------------------------------------------------ |
     | configurable | 是否可以删除目标属性或是否可以再次修改属性的特性,设为true可以,false不可以 |
     | writable     | 属性的值是否可以修改,设为true可以false不可以                 |
     | enumerable   | 属性是否可以被枚举                                           |
     | value        | 定义属性的属性值,默认为undefined                             |

  6. Object.freeze(obj)

     > 将一个对象的属性和方法冻结,冻结后不可修改

##### **ES6对象遍历**

- for...in循环遍历

- Object.keys(obj)

  > 将对象的可枚举属性的属性名(键名)保存在一个数组中返回,不包括Symbol属性

- Object.value(obj)

  > 将对象的可枚举属性的属性值(键值)保存在一个数组中返回,不包括Symbol属性的属性值

### Math对象

> math对象常用于算数计算,没有构造函数Math要访问属性和方法之间使用Math

**Math对象的属性**

**Math对象的方法**

| 方法                | 描述                      |
| ------------------- | ------------------------- |
| Math.abs(x)         | 返回x的绝对值             |
| Math.round(x)       | 返回x的四舍五入后的近似值 |
| Math.ceil(x)        | 返回X的近似值,向上取整    |
| Math.floor(x)       | 返回X的近似值,向下取整    |
| Math.random()       | 返回0-1的随机数           |
| Math.pow(x,y)       | 返回x的Y次幂              |
| Math.max(x,y,z,...) | 返回参数中的最大值        |
| Math.min(x,y,z...)  | 返回参数中的最小值        |

```js
//获取任意数字之间的随机数   x~y的随机数
Math.random() * (y - x) + x;
// 获取任意数字之间的随机整数 x ~ y 的随机整数
Math.floor(Math.random() * (y - x) + x);
/*
使用Math.floor()的随机性更加平均,round和ceil会导致两边的随机性变小
*/
```

### 正则对象

> 正则表达式一般用于匹配,替换符合某种模式(规则)的字符

**正则表达式的创建	**

- new.RegExp(正则表达式,模式修正符)

  - 模式修正符
    - i : 执行大小写不敏感的匹配
    - g : global的简写,执行全局匹配
    - m : 执行多行匹配

- var reg = /正则表达式/;

  > 在两个斜杠中间的字符不需要添加引号

#### 正则对象的组成部分

- 原子

  > 原子是正则表达式的最小单元

  | 原子   | 介绍                                           |
  | ------ | ---------------------------------------------- |
  | **\d** | **匹配一个0-9之间的字符,与[0-9]功能一致**      |
  | **\D** | **匹配一个除了0~9之外的字符,与[^0-9]功能一致** |
  | **\w** | **匹配数字,字母,下划线**                       |
  | **\W** | **匹配除了数字,字母,下划线以外的字符**         |
  | \s     | 匹配空格                                       |
  | \S     | 匹配非空格                                     |
  | **.**  | **匹配任意单个字符,除了换行和行结束符**        |
  | **\n** | **可以匹配换行字符,也可以作为换行字符**        |
  | \f     | 换页字符                                       |
  | \r     | 回车字符                                       |
  | \t     | 制表符                                         |
  | \v     | 垂直制表符                                     |

  | 原子      | 介绍                                 |
  | --------- | ------------------------------------ |
  | **[]**    | **匹配一个字符**                     |
  | **[^]**   | **匹配除了中括号内的字符以外的字符** |
  | **[0,9]** | **匹配一个0-9之间的字符**            |
  | **[a,z]** | **匹配小写a-z之间的字符**            |
  | **[A-Z]** | **匹配大写A-Z之间的字符**            |

- 量词

  | 量词  | 介绍                                     |
  | ----- | ---------------------------------------- |
  | {n}   | 将前面匹配的原子重复n次                  |
  | {n,}  | 将前面匹配的原子重复n及n次以上           |
  | {n,m} | 将前面匹配的原子重复n到m次               |
  | *     | 匹配一个原子重复0到无数次,与{0,}功能相同 |
  | +     | 匹配一个原子重复1到无数次,与{1,}功能相同 |
  | ?=n   | 匹配后面紧跟字符n的字符                  |
  | ?!n   | 匹配后面不跟字符n的字符                  |

- 边界

  | 字符       | 介绍                       |
  | ---------- | -------------------------- |
  | ^          | 从开头匹配                 |
  | $          | 匹配到字符串的末尾         |
  | \b         | 匹配单词边界               |
  | \B         | 匹配非单词边界             |
  | \|(管道符) | 左右两侧只要有一侧符合即可 |

##### 匹配模式

- 贪婪模式:尽可能多的匹配字符(默认状态下)
- 吝啬模式:尽可能少的匹配字符
  - *? 匹配0-无数次个字符,但是尽可能的少
  - +? 匹配1-无数次,但是尽可能的少
  - ?? 匹配0次或1次 但是尽可能的少
  - {n,m}? 匹配n-m次,但是尽可能的少
  - {n,}? 匹配n及n次以上,但是尽可能的少

##### 正则对象的方法

- reg.text(str)



### 内置顶层函数

> javascript将一些我们常用的功能封装成函数,在任何地方都可以访问这些函数,这些函数被称为内置顶层函数

- Number()

  > 将任意数据类型转换为数值型,如果无法转换结果为NaN

  ```js
  var num = 10;
  var str = "10";
  var str1 = "100aadad";
  Number(num);    // 10;
  Number(str);   // 10;
  Number(str1);  //NaN;
  Number(undefined); //NaN
  Numer(true);  // 1;
  Number(false);  //0;
  Number(null);  //0;
  ```

- parselnt()

  > 将任意数据类型转换为整型(整数),如果无法转换结果为NaN

  ```js
  parseInt(10)  //10
  parseInt(10.1111) //10
  parseInt(10.9999);  //10
  parseInt("1234daddw") // 1234
  parseInt("adwad15315") //NaN
  parseInt("    -15315adadwad")  // -15315
  parseInt(true)  //NaN	
  parseInt(false)	// NaN
  parseInt(undefined) // NaN
  parseInt(null);	//NaN
  parseInt(1010101,2); //85 当有两个参数时,第一个参数是被转换的数值,第二个参数是进制
  ```

- parseFloat()

  > 将任意数据类型转换为小数,如果无法转换结果为NaN

  ```js
  parseFloat("123.168.51.5100") // 123.168 //从第一个不为0的数字开始,到第一个有效的小数点结束
  ```

- Boolean()

  > 将任意数据类型转换成布尔值,结果为true或false

  **在JS中除了0,"",false,null,undefined,NaN,转换为布尔值为false,其他都为true**

- String()

  > 将任意数据类型转换成字符串型

- isNaN()

  > 判断一个数据是否能够转换为数值型

  - 如果可以返回false,如果不能返回true

    ```js
    isNaN(undefined) //true
    isNaN(null) //false
    isNaN(NaN)  // true
    ```

- eval()

  > 将字符串当成JS代码去执行

### 数据类型转换

> 在JS中运算时,有时需要将数据进行转换以后才能运行

#### 强制数据类型转换

- Number()
- parseInt()
- parseFloat()
- Boolean()
- String()

**详情请翻看内置顶层函数部分**

#### 隐式数据类型转换

- 算数运算符:会隐式的调用Number()函数将数据转为数值型进行运算(
- 关系运算符:会隐式的调用Number()函数将数据转为数值型进行比较
- 逻辑运算符:会隐式的调用Boolean()函数将数据转为布尔型进行运算
- 特殊的语句:
  - for,while,do-while会隐式调用Boolean函数
  - if,三元运算符会隐式调用Boolean函数

[^0,9]: 



## ES6新增特性

> - let  const
> - class
> - 数组和对象的解构赋值
> - 函数参数默认值的设置
> - rest参数
> - 扩展运算符
> - 箭头函数
> - 模板字符串
> - arr.includes
> - 块级作用域
> - 对象的简写语法
> - for....of

### Symbol

> 在JS中对象的属性名为字符串,当我们在引用他人设计的对象时,我们需要添加属于自己的属性,有可能会与原对象中的属性名发生冲突,命名会冲突,为了解决这样的问题,在ES6中引入了Symbol这种初始数据类型(原始数据类型),Symbol表示的是独一无二的值.

### Set和Map数据结构

- **Set**

  > Set类似于数组,但是其中的成员(数据)都是独一无二的,不会出现重复的值

  - **Set的属性**
    - Set.prototype.size:返回set数据结构的成员数量
    - Set.prototype.constructor:返回实例的构造函数
  - **Set实例的方法**
    - Set.add(x)添加一个Set数据成员,返回值是set数据结构本身
    - Set.delete(x)删除一个set数据成员返回值是布尔值,表示删除是否成功
    - set.has(x)判断set中是否存在某个数据成员返回值是布尔值
    - set.claar();清空整个set实例
    - set.keys():返回键名的遍历器
    - set.values()返回键值的遍历器
    - set.entries():返回键值对的遍历器
    - set.forEach():返回回调函数遍历每一个成员

- Map

  - Map实例的属性
    - Map.prototype.size:返回map数据结构的成员数量
    - Map.prototype.constructor:返回实例的构造函数
  - Map实例的方法
    - map.set()添加一个map成员,返回值是添加后的Map实例
    - map.delete():删除一个map成员返回值是布尔值,表示删除是否成功
    - map.get():查看一个map成员,返回值是被查看的成员,不存在会返回undefined
    - map.clear:清空map成员
    - map.has():判断是否存在一个map成员返回值是布尔值
    - map.key()返回键名的遍历器
    - map.values():返回全部键值的遍历器
    - map.entriex()返回所有键值对的遍历器
    - map.forEach():通过回调函数遍历出来所有的map成员

### Promise

#### 异步

> javaScript具有单线程异步的特性,整个JS代码只有一条线程,所有的代码都会走一个地方,这种情况下,如果一些代码需要触发条件才能执行,将会阻塞后续代码的执行,为了解决这个问题JS中具有异步的特性
>
> 异步:所谓异步指得是,在JS执行代码时,当遇到需要触发条件才能执行得代码得时候,不会等待这个条件触发,而会先执行后续得代码,由观察者监听条件得触发,如果条件触发,会在当前执行的代码结束后将触发条件后的代码插入到当前队列中执行,执行结束后再执行后续的代码

**解决异步的方法**

- 回调函数:一般用于在一段代码执行结束以后再去执行另一段代码
- 事件:只有事件在触发后才会执行内部的代码

#### ES6 promise

> promise是由社区最早提出的解决异步问题的方法,其实promise就是在内部封装有多个异步的状态,我们可以根据异步状态去执行相应的代码.

- Promise内部封装的异步操作的状态
  - pending:进行中
  - fulfilled:已成功
  - rejected:已失败
- 内部状态的变化只有两种
  - pending -> fulfilled
  - pending -> rejected 
- promise对象的方法
  - promise.then(callback); 异步操作成功后,接收回调函数的方法
  - promise.catch(callback); 异步操作失败后,接收回调函数的方法
- promise构造函数的方法
  - promise.resolve();定义一个异步操作成功的函数
  - Promise.all():将多个promise对象封装成一个promise对象
  - Promise.reject();定义一个异步操作失败的函数

### Class类

> class可以看做是构造函数的语法糖,在ES5中没有类的概念,会让人们觉得不好理解,于是在ES6中引入了class类的概念

```js
class 类名 {
    constructor(参数1,参数2....){
        // 私有属性
        this.属性1 = 参数1;
        this.属性2 = 参数2;
        ...
    }
        
    //方法 :等同于在构造函数的原型中添加方法
        方法(参数...){
            // 函数体
        }
}
```

- ES6class类的继承

```js
class Father {
    constructor(){
        
    }
}

class Son extend Father{
    constructor(){
        super();  //调用super函数即调用父类的构造函数,实现真正意义的继承
    }
}
```





### 打字游戏

#### 准备工作

- 游戏界面设计
- 游戏界面网页布局
- 进行兼容性调整
- 切图工作,将对应的字母元素的图片切好,并且图片命名为小写字母

#### 进行项目开发

##### 开始游戏功能

- 给用户一个按钮,进行开始游戏的操作
  - 点击开始按钮将开始界面隐藏
  - 开始界面隐藏后,加载页面显示

**加载中**

- 进度条效果
- 进度条完成后进入游戏界面,同时加载页面隐藏

**游戏中**

1. 获取页面中需要操作的元素,注意:需要多次使用的变量应该设为全局变量,并且放在代码的最顶端

2. 声明变量timer保存时间函数

3. 定义函数createlmage用来生成页面中的字母元素

   > 通过for循环,不断的创建img标签,通过随机数获取随机的字母,将这个字母作为img的类名,用于区分这些img标签,根据这个随机的字母添加src属性,进行图片的展示,给img标签添加定位属性,实现在随机的位置出现字母元素,创建好后添加到游戏界面中.
   >
   > - Math.random()
   > - Math.floor()
   > - parseInt()
   > - String.fromCharCode()
   > - DOM元素的属性操作,className   src   行内样式
   > - node.appendChild()

4. 定义函数imgAnimate来给页面的字母元素添加下落的动画

   - 获取到页面中的所有字母元素

   - 判断字母元素的个数是否满足需要,(默认页面保存5个字母元素),如果满足就继续,不满足就创建字母元素就是调用(createlmage函数)

   - 判断页面中是否存在字母元素.存在就添加动画,不存在就不执行

     - 通过for循环给每一个字母元素都添加动画

       > 不断的修改当前字母元素距离顶部的距离实现动画
       >
       > 1.获取元素当前距离顶部的距离,var current =  ele.offsetTop
       >
       > 2.将元素距离顶部的距离按照一定的速度进行修改 current +=speed
       >
       > 3.值变化后,需要将结果体现到页面中,通过修改元素的行内样式实现动画 ele.style.top = cuurent +"px"
       >
       > 4.元素不能一直向下掉落,需要进行最大值的判断,如果达到了最大值就将这个元素移出  node.removeChild(ele)

   - 通过setInterval时间函数,每过一段时间调用一次动画函数,实现页面元素的创建以及动画

   **node.children   if     length    元素尺寸相关知识  no.removeCh**

5. 添加交互效果

   - 监听window的键盘按下事件

   - 根据事件对象中的事件信息获取当前按下的键盘字母  e.key / e.keycode

   - 获取页面中的字母元素

   - for循环将所有字母元素进行遍历,将元素的类名与用户按下的键盘字母进行比较,如果相同就移出,(在移出第一个元素后break终止,防止一次消除多个字母bug出现)

     > ele.className
     >
     > e.key  /e.keycode
     >
     > break循环控制语句

6. 定义starGame函数,用于开始整个函数

   **在恰当的位置,恰当的时候调用startGame函数**

7. 代码整理,将公共常用的代码进行封装,去掉不必要的变量以及不必要的测试语句



## JQuery

> jquery是封装起来的js函数库
>
> 它是一个对象,这个对象内部封装了大量用于操作DOM元素的方法,Jquery的最大优势就是操作DOM元素更加方便

### JQuery的特点

- **隐式循环**

  > 在jQuery内部封装了大量的循环机制,可以将我们需要设置的样式或属性通过内部的循环机制设置到需要的所有的元素中去,这个循环的过程我们看不到,所以叫隐式循环

- **链式调用**

  > 当我们在使用对象的方法时,只有这个对象能够访问自己内部的方法,所以在jQuery中大部分方法的返回值都是jQuery本身,所以可以不断的去进行链式调用(调用jq内部的方法)

### 本地存储

> 在平时浏览网页时,在进行登录注册的时候,会记住登录状态,这个时候就会在客户端存储与用户相关的信息这里JS为我们提供了三种在客户端存储数据的方法,cookie  localStrage    sessionStorage

#### cookie

> 保存在客户端的一种小文件,能够存储4kb的数据,并且每一个Web站点最多可以存储20个cookie

| 特点                | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| 存储方法            | 键值对的形式存储                                             |
| 存储的数据大小,数量 | 4kb,不超过20个                                               |
| 清理机制            | IE   opera(歌剧)浏览器会定期情理最近不常用的cookie  而FireFox会随机清理cookie |
| 缺点                | 在同域中浏览或访问也会携带cookie ,占用带宽                   |
| 应用                | 购物车,登录状态                                              |

**cookie的使用需要借助服务器环境,不同域名的cookie值不能互相访问**

#### localStorage

> H5为我们提供的更为强大的客户端存储的方式,存储数据更加高效便捷,并且,能够存储的数据量大大增加,在5-10M,但是对于一个Web应用而言,已经足够了.这种方式是永久性存储,只要不人为删除就不会出现数据丢失的现象

| 特点           | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| 存储方式       | 键值对                                                       |
| 存储数据大小   | 5-10M                                                        |
| 清理机制       | 永久性存储                                                   |
| 存储的数据内容 | 必须是字符串,如果需要存储数组等对象类型,需要将他们序列化成字符串JSON.stringiy() |
| 应用           | 保存ajax请求的需要长期保存的数据                             |
| 缺点           | 不能进行跨域共享,所以不要存储与业务关键相关的信息,更不要存储重要的安全信息 |

| 属性                            | 介绍                          |
| ------------------------------- | ----------------------------- |
| localStorage.length             | 本地存储中的数据个数          |
| localStorage.key(n)             | 获取本地存储中的第n个值得键名 |
| localStorage.键名= 键值         | 向本地存储中添加一个数据      |
| localStorage.setltem(键名,键值) | 向本地存储中添加一个数据      |
| localStorage.getltem(键名)      | 获取本地存储中得数据          |
| localStorage.removeltem(键名)   | 移出本地存储中得数据          |
| localStorage.clear()            | 清空本地存储                  |

### sessionStorage

> sessionStorage是一种会话型存储,不能跨平台访问,在窗口关闭后,sessionStorage存储被删除

### sessionStorage .cookie  localStorage得区别

- 存储数据得量

  cookie存储数据量只有4kb并且上线为20

  localStorage sessionStorage 存储数据量较多 5-10M

- 存储数据的时间

  cookie会根据设置的有效时间进行存储

  localStorage是永久性存储

  sessionStorage是会话型存储

- 共同点

  都是保存在浏览器端的,并且都是同域的,跨域不能进行访问